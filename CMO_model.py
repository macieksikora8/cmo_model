# -*- coding: utf-8 -*-
"""
Created on Mon Jan  4 23:05:39 2021

@author: Maciej Sikora
"""

#! python3
import numpy_financial as npf 
import numpy as np
from math import atan, pi
import pandas as pd
import altair as alt

#function to generate path of interest rates with Cox-Ingersoll-Ross model 
#last -> last observation, starting point for the path
#a -> speed of adjustment to the mean
#b -> long-term mean
# sigma -> standard deviation 
#n -> number of interested rates to be generated by the function
def CIR(last, a, b, sigma, n):

    rates = np.array([last])
    for n in range(1,n):
        w = np.random.normal(0,1)
        dr = a * (b - rates[-1]) + sigma*w*(rates[-1]**(1/2))
        r = rates[-1] + dr
        rates = np.append(rates, r)
    return rates

#function to calculate value of Refinancing Incentive factor
# r -> current mortgage rate 
def RefinIncent(r, maxCPR, minCPR, WAC, slope):
    
    a = (minCPR+maxCPR)/2 
    b = (maxCPR-a)/(pi/2) 
    d = slope / b * 100
    c = -d * 0.02 #assuming 200 bps difference between C and R 
 
    return a + b*(atan(c+d*(WAC - r)))

#identifying month for Monthly Multiplier factor
def month(n):
    if n%12 != 0:
        m = (n%12) 
    else: 
        m = 12
    return m 

#funtion returning Single Month Mortality based on CPR calculated with Richard and Roll (1989) prepayment model 
def RichardRoll(r, maxCPR, minCPR, WAC, slope, balance, size, i):

    RI = RefinIncent(r, maxCPR, minCPR, WAC, slope)
    SM = min(i/30,1)
    monthly_multiplier = np.array([0.94, 0.76, 0.74, 0.95, 0.98, 0.92, 0.98, 1.1, 1.18, 1.22, 1.23, 0.98])
    MM = monthly_multiplier[month(i)-1]
    BM = 0.3 + 0.7*(balance/size)
    
    cpr = RI * SM * MM * BM
    smm = 1 - (1-cpr)**(1/12)
    return smm 

#function to calculate monthly default rate according to SDA benchmark
def SDA(speed, month):
    if month <= 30:
        cdr = 0.0002 * (speed/100) * month
    elif month > 30 and month <= 60:
        cdr = 0.006 * (speed/100)
    elif month > 60 and month <= 120:
        cdr = 0.006 * (speed/100) - (month-60) * 0.000095 * (speed/100)
    else:
        cdr = 0.0003 * (speed/100)
        
    mdr = 1 - (1-cdr)**(1/12)
    return mdr

#function returning a dictionary of numpy arrays with cash flows generated by the pool
#size -> size of the pool (in millions)
#sda -> SDA (in %) 
#WAC -> Weighted Average Coupon
#netC -> net coupon (WAC - servicing fee)
#lag -> time to liquidation
#rr -> recovery rate (1 - loss severity)
#WAM -> Weighted Average Maturity 
def poolCashFlows(size, sda, WAM, WAC, netC, last, lag, rr):
    rates = CIR(last, 0.089603, 0.039538, 0.00809439, WAM) #calibrated values
    balance = size
    
    interestCF = np.array([])
    principalCF = np.array([]) 
    defaultED = np.array([])
    
    i = 0    
    while balance > 0:    
        interest = balance * (netC/12) 
        principal = -npf.pmt(netC/12, WAM-i, balance) - interest
        prepayment = (balance - principal) * RichardRoll(rates[i], 0.5, 0, WAC, 0.6, balance, size, i+1)
        default = (balance - (principal + prepayment)) * SDA(sda, i+1)
        
        if i > lag: 
            recovery = defaultED[i-lag-1] * rr
        else: 
            recovery = 0 
            
        if balance - principal - prepayment <0: 
            break
        elif i < lag:
            balance = balance - principal - prepayment - default 
        else:
            balance = balance - principal - prepayment - default - recovery 
        
        interestCF = np.append(interestCF, interest)
        principalCF = np.append(principalCF, principal + prepayment + recovery) 
        defaultED = np.append(defaultED, default)
        i += 1
    #cash flows in the final period 
    interest = balance * (netC/12)
    principal = balance
    recovery = defaultED[WAM-lag-2] * rr
    
    interestCF = np.append(interestCF, interest)
    principalCF = np.append(principalCF, principal + recovery)
    defaultED = np.append(defaultED, 0)
    totalCF = interestCF + principalCF 

    return {'interest':interestCF, 'principal':principalCF, 'defaults':defaultED, 'total': totalCF} 

#function to identify the month until which losses are covered by overcollateralization
def coveredLosses(a, oc, size):
    for j, cf in enumerate(np.cumsum(a)):
            if cf >= oc * size:
                break
    return j

#function that resets balance of each tranche    
def setBalance(tranches, size):
    for t, tranche in enumerate(tranches):
        tranche['balance'] = size * tranche['size']
        
#helper function to create additional arrays in dictionaries with tranche characteristics 
def addArraysToStore(tranches):
    for tranche in tranches:
        tranche['WAL'] = np.array([])
        tranche['yield'] = np.array([])
        tranche['avgWALs'] = np.array([])
        tranche['avgYields'] = np.array([])  

#distributing pools' cash flows to each tranche
#tranches -> list of dictionaries specifying tranches
#oc -> size of overcollateralization (in % of the size of the pool)
def waterfallCF(size, sda, WAM, WAC, netC, last, lag, rr, tranches, oc):

    setBalance(tranches, size)
    assets = poolCashFlows(size, sda, WAM, WAC, netC, last, lag, rr)
    
    for i, elem in enumerate(assets['interest']):
        
        avail_interest = assets['interest'][i]
        avail_principal = assets['principal'][i]
        avail_default = assets['defaults'][i]
        covered_period = coveredLosses(assets['defaults'], oc, size)
        
        for t ,tranche in enumerate(tranches):
            if t == len(tranches) - 1:
            #distributions for the Residual tranche
                if  i <= covered_period:
                    received_interest = avail_interest
                    received_principal = avail_principal
                        
                    tranche_cf = received_interest + received_principal
                    tranche['cash_flows'] = np.append(tranche['cash_flows'], tranche_cf)
                else:
                    avail_default = avail_default - avail_interest - avail_principal
                    for d in reversed(tranches):
                        decrease = min(d['balance'], avail_default)
                        d['balance'] = d['balance']  - decrease
                        avail_default = avail_default - decrease
                    
            else: 
            #disteributions for remaining tranches
                accrued_interest = tranche['balance'] * (tranche['coupon']/12)
                received_interest = min(avail_interest, accrued_interest)
                received_principal = min(avail_principal, tranche['balance'])
            
                tranche['balance'] = tranche['balance'] - received_principal
                
                avail_interest = avail_interest - received_interest
                avail_principal = avail_principal - received_principal 
                
                tranche_cf = received_interest + received_principal
                tranche['cash_flows'] = np.append(tranche['cash_flows'], tranche_cf)

#calculating WAL for each tranche
def WAL(tranche):
    wcf = []
    for i, elem in enumerate(tranche['cash_flows']):
        weighted_cf = (i+1) * elem
        wcf = np.append(wcf, weighted_cf)
    
    wal = np.sum(wcf) / np.sum(tranche['cash_flows'])
    return wal 

#calculating IRR (i.e. cash flow yield) for each tranche
def trancheIRR(size, tranche, tranches, oc, i):
    if i == len(tranches) - 1:
        a = np.array([-size*oc]) 
    else:
        a = np.array([-size*tranche['size']])
    irr = 12*npf.irr(np.append(a, tranche['cash_flows']))
    return irr

#function that resets cash flows distributed to each tranche before next simulation       
def zeroCashFlows(tranches):
    for tranche in tranches:
        tranche['cash_flows'] = np.array([])

#function that resets yields and WALs for each before next simulation     
def zeroMCKeys(tranches):
    for tranche in tranches:
         tranche['WAL'] = np.array([])
         tranche['yield'] = np.array([])
         
         
#function performing MC simulation and appending arrays in the tranches' dictionaries 
#n -> number of simulations
def MonteCarlo(size, sda, WAM, WAC, netC, last, lag, rr, tranches, oc, n):     
    for m in range(n):
        waterfallCF(size, sda, WAM, WAC, netC, last, lag, rr, tranches, oc)
        for i, tranche in enumerate(tranches):
            tranche['WAL'] = np.append(tranche['WAL'], WAL(tranche))
            tranche['yield'] = np.append(tranche['yield'],trancheIRR(size, tranche, tranches, oc, i))
        zeroCashFlows(tranches)
    for tranche in tranches:
        tranche['avgWALs'] = np.append(tranche['avgWALs'], np.mean(tranche['WAL']))
        tranche['avgYields'] = np.append(tranche['avgYields'], np.mean(tranche['yield']))
    zeroMCKeys(tranches)

#function to calcualte the data for the chart and store them in a csv file in the directory
def sourceData(sda_range, size, WAM, WAC, netC, last, lag, rr, tranches, oc, n): 

    addArraysToStore(tranches)
    for d in sda_range:
        MonteCarlo(size, d, WAM, WAC, netC, last, lag, rr, tranches, oc, n)
    
    df = pd.DataFrame({'x': [n/100 for n in sda_range], 
                        'A': tranches[0]['avgYields'],
                        'B': tranches[1]['avgYields'],
                        'C': tranches[2]['avgYields'],
                        'D': tranches[3]['avgYields'],
                        'Residual': tranches[4]['avgYields']
                        })
    
    source = pd.melt(df, id_vars =['x'], value_vars =['A', 'B', 'C', 'D', 'Residual'], var_name='variable')
    source.to_csv('source.csv', index=False)

#'Sensitivity of CMO Yield' chart
#source -> needs to be pandas Data Frame
def yieldSensitivityChart(source, sda_range):

    chart = alt.Chart(source).mark_line(point=True, size=5).encode(
    x= alt.X('x', axis=alt.Axis(values=[n/100 for n in sda_range], format='%', title='SDA', labelSeparation=10, labelFlush=False)),
    y= alt.Y('value', axis=alt.Axis(tickCount=10, format='%', title='Yield')),
    color= alt.Color('variable', scale=alt.Scale(scheme = 'blues'), legend=alt.Legend(labelFont='Open Sans',
                                                                                      labelFontSize=14,
                                                                                      titleFont='Open Sans',
                                                                                      titleFontSize=14,
                                                                                      titleFontWeight='normal',
                                                                                      title="Class:")
                    ) 
    ).properties(title="Sensitivity of CMO Yield", width=600, height=350)
    
    chart.configure_title(
        fontSize=32,
        font='Lato Light',
        align='center',
        color='black',
        fontWeight=100
    ).configure_axis(
        titleFont='Lato Light',
        titleFontSize=25,
        titleFontWeight=200,
        labelFont='Open Sans',
        labelFontSize=14,
        labelPadding=10,
        gridColor='#e2e2e2'
    ).configure_point(
        size=60
    ).display()
        
#defining tranches as a list of dictionaries 
#tranches must be in order of seniority
tranches = [
    {'size':0.60, 'coupon':0.010, 'balance':0, 'cash_flows': np.array([])},
    {'size':0.15, 'coupon':0.020, 'balance':0, 'cash_flows': np.array([])},
    {'size':0.15, 'coupon':0.035, 'balance':0, 'cash_flows': np.array([])},
    {'size':0.03, 'coupon':0.055, 'balance':0, 'cash_flows': np.array([])},
    {'size':0.00, 'coupon':0.000, 'balance':0, 'cash_flows': np.array([])} #Residual tranche
           ]

#specifying SDA levels for sensitivity analysis
sda_range = list(range(50,425,25))

#applying sample values from the example
sourceData(sda_range, 300_000_000, 357, 0.035, 0.03, 0.0272, 14, 0.8, tranches, 0.07, 1)

